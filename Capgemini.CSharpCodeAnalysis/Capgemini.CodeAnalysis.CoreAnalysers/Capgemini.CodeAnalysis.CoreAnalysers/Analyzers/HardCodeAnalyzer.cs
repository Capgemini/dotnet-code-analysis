using System.Collections.Immutable;
using System.Linq;
using Capgemini.CodeAnalysis.Foundation;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Capgemini.CodeAnalysis.CoreAnalysers.Analyzers
{
    /// <summary>
    ///Hard-coded values must be avoided at all costs.This applies to string literals as well as numeric identifiers, and must be declared as constants, variables or fields as appropriate.Enums for OptionSetValues and constants for entity and attribute logical names generated by the Early-Bound entity model generator must be used instead
    /// </summary>
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public class HardCodeAnalyzer : AnalyzerBase
    {
        internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(AnalyserConstants.HardCodeAnalyzerId, nameof(HardCodeAnalyzer),
            $"{nameof(HardCodeAnalyzer)}: {{0}}", AnalyserCategoryConstants.CodeStructure, DiagnosticSeverity.Error, true);

        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);

        public override void Initialize(AnalysisContext context)
        {
            ///todo:will reintroduce in later release
            //context.RegisterSyntaxNodeAction(AnalyzeStringLiteralsWithinMethods, SyntaxKind.MethodDeclaration);
        }

        private void AnalyzeStringLiteralsWithinMethods(SyntaxNodeAnalysisContext context)
        {
            var declaration = Cast<MethodDeclarationSyntax>(context.Node);
            var literals = declaration.Body?.DescendantNodes().OfType<LiteralExpressionSyntax>().Where(x => x.IsKind(SyntaxKind.StringLiteralExpression)).ToList();
            if (literals != null)
            {
                foreach (var literal in literals)
                {
                    if (!literal.Parent.IsKind(SyntaxKind.ArrayInitializerExpression) && 
                        !literal.Parent.IsKind(SyntaxKind.EqualsExpression) && 
                        !literal.Parent.IsKind(SyntaxKind.CaseSwitchLabel) && 
                        !IsParentAnException(literal))
                    {
                        if (ParentDeclarationIsNotConstant(literal))
                        {
                            DiagnosticsManager.CreateHardCodedValueDiagnostic(context, literal.GetLocation(), Rule,
                                literal.GetText().ToString());
                        }
                    }
                }
            }
        }

        private static bool ParentDeclarationIsNotConstant(LiteralExpressionSyntax syntax)
        {
            LocalDeclarationStatementSyntax localDeclaration = null;

            var fieldDeclaration = syntax.Ancestors()
                                          .OfType<FieldDeclarationSyntax>()
                                          .FirstOrDefault(x => x.Modifiers.Any(SyntaxKind.ConstKeyword));

            if (fieldDeclaration == null)
            {
                localDeclaration = syntax.Ancestors()
                                        .OfType<LocalDeclarationStatementSyntax>()
                                        .FirstOrDefault(x => x.Modifiers.Any(SyntaxKind.ConstKeyword));
            }
            return fieldDeclaration == null && localDeclaration == null;
        }
    }
}